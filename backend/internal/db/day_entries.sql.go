// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: day_entries.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createDayEntry = `-- name: CreateDayEntry :one
INSERT INTO day_entries (calendar_id, date, color_meaning_id, notes)
VALUES ($1, $2, $3, $4)
RETURNING id, calendar_id, date, color_meaning_id, notes, created_at, updated_at
`

type CreateDayEntryParams struct {
	CalendarID     uuid.UUID      `json:"calendar_id"`
	Date           time.Time      `json:"date"`
	ColorMeaningID uuid.UUID      `json:"color_meaning_id"`
	Notes          sql.NullString `json:"notes"`
}

func (q *Queries) CreateDayEntry(ctx context.Context, arg CreateDayEntryParams) (DayEntry, error) {
	row := q.db.QueryRowContext(ctx, createDayEntry,
		arg.CalendarID,
		arg.Date,
		arg.ColorMeaningID,
		arg.Notes,
	)
	var i DayEntry
	err := row.Scan(
		&i.ID,
		&i.CalendarID,
		&i.Date,
		&i.ColorMeaningID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDayEntry = `-- name: DeleteDayEntry :exec
DELETE FROM day_entries
WHERE calendar_id = $1 AND date = $2
`

type DeleteDayEntryParams struct {
	CalendarID uuid.UUID `json:"calendar_id"`
	Date       time.Time `json:"date"`
}

func (q *Queries) DeleteDayEntry(ctx context.Context, arg DeleteDayEntryParams) error {
	_, err := q.db.ExecContext(ctx, deleteDayEntry, arg.CalendarID, arg.Date)
	return err
}

const getDayEntriesByCalendarID = `-- name: GetDayEntriesByCalendarID :many
SELECT de.id, de.calendar_id, de.date, de.color_meaning_id, de.notes, de.created_at, de.updated_at, cm.color_hex, cm.meaning
FROM day_entries de
JOIN color_meanings cm ON de.color_meaning_id = cm.id
WHERE de.calendar_id = $1
ORDER BY de.date DESC
`

type GetDayEntriesByCalendarIDRow struct {
	ID             uuid.UUID      `json:"id"`
	CalendarID     uuid.UUID      `json:"calendar_id"`
	Date           time.Time      `json:"date"`
	ColorMeaningID uuid.UUID      `json:"color_meaning_id"`
	Notes          sql.NullString `json:"notes"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ColorHex       string         `json:"color_hex"`
	Meaning        string         `json:"meaning"`
}

func (q *Queries) GetDayEntriesByCalendarID(ctx context.Context, calendarID uuid.UUID) ([]GetDayEntriesByCalendarIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getDayEntriesByCalendarID, calendarID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDayEntriesByCalendarIDRow
	for rows.Next() {
		var i GetDayEntriesByCalendarIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CalendarID,
			&i.Date,
			&i.ColorMeaningID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ColorHex,
			&i.Meaning,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDayEntriesByDateRange = `-- name: GetDayEntriesByDateRange :many
SELECT de.id, de.calendar_id, de.date, de.color_meaning_id, de.notes, de.created_at, de.updated_at, cm.color_hex, cm.meaning, c.name as calendar_name
FROM day_entries de
JOIN color_meanings cm ON de.color_meaning_id = cm.id
JOIN calendars c ON de.calendar_id = c.id
WHERE c.user_id = $1 
  AND de.date >= $2 
  AND de.date <= $3
ORDER BY de.date DESC, c.name
`

type GetDayEntriesByDateRangeParams struct {
	UserID uuid.UUID `json:"user_id"`
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
}

type GetDayEntriesByDateRangeRow struct {
	ID             uuid.UUID      `json:"id"`
	CalendarID     uuid.UUID      `json:"calendar_id"`
	Date           time.Time      `json:"date"`
	ColorMeaningID uuid.UUID      `json:"color_meaning_id"`
	Notes          sql.NullString `json:"notes"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ColorHex       string         `json:"color_hex"`
	Meaning        string         `json:"meaning"`
	CalendarName   string         `json:"calendar_name"`
}

func (q *Queries) GetDayEntriesByDateRange(ctx context.Context, arg GetDayEntriesByDateRangeParams) ([]GetDayEntriesByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getDayEntriesByDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDayEntriesByDateRangeRow
	for rows.Next() {
		var i GetDayEntriesByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.CalendarID,
			&i.Date,
			&i.ColorMeaningID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ColorHex,
			&i.Meaning,
			&i.CalendarName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDayEntryByCalendarAndDate = `-- name: GetDayEntryByCalendarAndDate :one
SELECT de.id, de.calendar_id, de.date, de.color_meaning_id, de.notes, de.created_at, de.updated_at, cm.color_hex, cm.meaning
FROM day_entries de
JOIN color_meanings cm ON de.color_meaning_id = cm.id
WHERE de.calendar_id = $1 AND de.date = $2
`

type GetDayEntryByCalendarAndDateParams struct {
	CalendarID uuid.UUID `json:"calendar_id"`
	Date       time.Time `json:"date"`
}

type GetDayEntryByCalendarAndDateRow struct {
	ID             uuid.UUID      `json:"id"`
	CalendarID     uuid.UUID      `json:"calendar_id"`
	Date           time.Time      `json:"date"`
	ColorMeaningID uuid.UUID      `json:"color_meaning_id"`
	Notes          sql.NullString `json:"notes"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ColorHex       string         `json:"color_hex"`
	Meaning        string         `json:"meaning"`
}

func (q *Queries) GetDayEntryByCalendarAndDate(ctx context.Context, arg GetDayEntryByCalendarAndDateParams) (GetDayEntryByCalendarAndDateRow, error) {
	row := q.db.QueryRowContext(ctx, getDayEntryByCalendarAndDate, arg.CalendarID, arg.Date)
	var i GetDayEntryByCalendarAndDateRow
	err := row.Scan(
		&i.ID,
		&i.CalendarID,
		&i.Date,
		&i.ColorMeaningID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ColorHex,
		&i.Meaning,
	)
	return i, err
}

const updateDayEntry = `-- name: UpdateDayEntry :one
UPDATE day_entries
SET color_meaning_id = $2, notes = $3, updated_at = NOW()
WHERE calendar_id = $1 AND date = $4
RETURNING id, calendar_id, date, color_meaning_id, notes, created_at, updated_at
`

type UpdateDayEntryParams struct {
	CalendarID     uuid.UUID      `json:"calendar_id"`
	ColorMeaningID uuid.UUID      `json:"color_meaning_id"`
	Notes          sql.NullString `json:"notes"`
	Date           time.Time      `json:"date"`
}

func (q *Queries) UpdateDayEntry(ctx context.Context, arg UpdateDayEntryParams) (DayEntry, error) {
	row := q.db.QueryRowContext(ctx, updateDayEntry,
		arg.CalendarID,
		arg.ColorMeaningID,
		arg.Notes,
		arg.Date,
	)
	var i DayEntry
	err := row.Scan(
		&i.ID,
		&i.CalendarID,
		&i.Date,
		&i.ColorMeaningID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
