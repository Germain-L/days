<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/germainleignel/days/viewmodel/DayTrackerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/germainleignel/days/viewmodel/DayTrackerViewModel.kt" />
              <option name="originalContent" value="package com.germainleignel.days.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.compose.runtime.mutableStateMapOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.germainleignel.days.data.AppSettings&#10;import com.germainleignel.days.data.ColorPalette&#10;import com.germainleignel.days.data.ColorWithMeaning&#10;import com.germainleignel.days.data.model.Calendar&#10;import com.germainleignel.days.data.model.CalendarData&#10;import com.germainleignel.days.data.getDefaultColors&#10;import com.germainleignel.days.storage.DataRepository&#10;import com.germainleignel.days.storage.RepositoryFactory&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;&#10;/**&#10; * Sealed class for different types of errors&#10; */&#10;sealed class DayTrackerError {&#10;    object StorageError : DayTrackerError()&#10;    object NetworkError : DayTrackerError()&#10;    data class ValidationError(val message: String) : DayTrackerError()&#10;    object UnknownError : DayTrackerError()&#10;}&#10;&#10;class DayTrackerViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val repository: DataRepository = RepositoryFactory.getRepository(application)&#10;&#10;    // App settings state&#10;    private val _settings = MutableStateFlow(AppSettings())&#10;    val settings = _settings.asStateFlow()&#10;&#10;    // Calendar data state&#10;    private val _calendarData = MutableStateFlow(CalendarData(emptyList()))&#10;    val calendarData = _calendarData.asStateFlow()&#10;&#10;    // Map to store colored days (date -&gt; color) - cached from repository&#10;    private val _coloredDays = mutableStateMapOf&lt;LocalDate, Color&gt;()&#10;    val coloredDays: Map&lt;LocalDate, Color&gt; = _coloredDays&#10;&#10;    // Current selected date for detailed view&#10;    private val _selectedDate = mutableStateOf&lt;LocalDate?&gt;(null)&#10;    val selectedDate = _selectedDate&#10;&#10;    // Loading states&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading = _isLoading.asStateFlow()&#10;&#10;    // Error states&#10;    private val _error = MutableStateFlow&lt;DayTrackerError?&gt;(null)&#10;    val error = _error.asStateFlow()&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                // Load settings&#10;                _settings.value = repository.getSettings()&#10;&#10;                // Load calendar data&#10;                _calendarData.value = repository.getCalendarData()&#10;&#10;                // Load colored days for current calendar&#10;                val savedDays = repository.getAllColoredDays()&#10;                _coloredDays.clear()&#10;                _coloredDays.putAll(savedDays)&#10;            } catch (e: Exception) {&#10;                // Handle loading errors gracefully&#10;                _settings.value = AppSettings()&#10;                _calendarData.value = CalendarData(emptyList())&#10;                _error.value = DayTrackerError.StorageError&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Calendar management methods&#10;    fun createCalendar(name: String, colors: List&lt;ColorWithMeaning&gt;) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val newCalendar = Calendar.createDefault(name, colors)&#10;                repository.saveCalendar(newCalendar)&#10;                _calendarData.value = repository.getCalendarData()&#10;            } catch (e: Exception) {&#10;                _error.value = DayTrackerError.StorageError&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteCalendar(calendarId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.deleteCalendar(calendarId)&#10;                _calendarData.value = repository.getCalendarData()&#10;                // Reload colored days if the deleted calendar was selected&#10;                if (_calendarData.value.selectedCalendarId != calendarId) {&#10;                    val savedDays = repository.getAllColoredDays()&#10;                    _coloredDays.clear()&#10;                    _coloredDays.putAll(savedDays)&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = DayTrackerError.StorageError&#10;            }&#10;        }&#10;    }&#10;&#10;    fun selectCalendar(calendarId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.setSelectedCalendar(calendarId)&#10;                _calendarData.value = repository.getCalendarData()&#10;                &#10;                // Load colored days for the selected calendar&#10;                val savedDays = repository.getAllColoredDays()&#10;                _coloredDays.clear()&#10;                _coloredDays.putAll(savedDays)&#10;            } catch (e: Exception) {&#10;                _error.value = DayTrackerError.StorageError&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateCalendar(calendar: Calendar) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.saveCalendar(calendar)&#10;                _calendarData.value = repository.getCalendarData()&#10;            } catch (e: Exception) {&#10;                _error.value = DayTrackerError.StorageError&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getSelectedCalendar(): Calendar? {&#10;        return _calendarData.value.getSelectedCalendar()&#10;    }&#10;&#10;    fun getCalendars(): List&lt;Calendar&gt; {&#10;        return _calendarData.value.calendars&#10;    }&#10;&#10;    fun getCurrentCalendarColors(): List&lt;ColorWithMeaning&gt; {&#10;        return getSelectedCalendar()?.colorScheme ?: getAvailableColorsWithMeanings()&#10;    }&#10;&#10;    /**&#10;     * Clear the current error state&#10;     */&#10;    fun clearError() {&#10;        _error.value = null&#10;    }&#10;&#10;    /**&#10;     * Retry loading data after an error&#10;     */&#10;    fun retryLoadData() {&#10;        loadData()&#10;    }&#10;&#10;    fun toggleDayColor(date: LocalDate) {&#10;        viewModelScope.launch {&#10;            val currentColor = _coloredDays[date]&#10;            if (currentColor != null) {&#10;                // If day is already colored, remove the color&#10;                removeDayColor(date)&#10;            } else {&#10;                // Color the day with the currently selected color&#10;                setDayColor(date, _settings.value.selectedColor)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setDayColor(date: LocalDate, color: Color) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _error.value = null&#10;                if (color == Color.Transparent) {&#10;                    // Transparent color means remove the color&#10;                    repository.removeDayColor(date)&#10;                    _coloredDays.remove(date)&#10;                } else {&#10;                    repository.saveDayColor(date, color)&#10;                    _coloredDays[date] = color&#10;                }&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;                _error.value = DayTrackerError.StorageError&#10;            }&#10;        }&#10;    }&#10;&#10;    fun removeDayColor(date: LocalDate) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.removeDayColor(date)&#10;                _coloredDays.remove(date)&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearAllColors() {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.clearAllDayColors()&#10;                _coloredDays.clear()&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateSelectedColor(color: Color) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val newSettings = _settings.value.copy(selectedColor = color)&#10;                repository.saveSettings(newSettings)&#10;                _settings.value = newSettings&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateDarkMode(isDarkMode: Boolean) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val newSettings = _settings.value.copy(&#10;                    isDarkMode = isDarkMode,&#10;                    followSystemTheme = false // When manually set, don't follow system&#10;                )&#10;                repository.saveSettings(newSettings)&#10;                _settings.value = newSettings&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setFollowSystemTheme(follow: Boolean) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val newSettings = _settings.value.copy(followSystemTheme = follow)&#10;                repository.saveSettings(newSettings)&#10;                _settings.value = newSettings&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateColorMeaning(color: Color, meaning: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedColors = _settings.value.availableColors.map { colorWithMeaning -&gt;&#10;                    if (colorWithMeaning.color == color) {&#10;                        colorWithMeaning.copy(meaning = meaning)&#10;                    } else {&#10;                        colorWithMeaning&#10;                    }&#10;                }&#10;                val newSettings = _settings.value.copy(availableColors = updatedColors)&#10;                repository.saveSettings(newSettings)&#10;                _settings.value = newSettings&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getColorMeaning(color: Color): String {&#10;        return getCurrentCalendarColors().find { it.color == color }?.meaning ?: &quot;Custom Color&quot;&#10;    }&#10;&#10;    fun addNewColor(color: Color, meaning: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedColors = _settings.value.availableColors + ColorWithMeaning(color, meaning)&#10;                val newSettings = _settings.value.copy(availableColors = updatedColors)&#10;                repository.saveSettings(newSettings)&#10;                _settings.value = newSettings&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteColor(color: Color) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedColors = _settings.value.availableColors.filter { it.color != color }&#10;                var newSettings = _settings.value.copy(availableColors = updatedColors)&#10;&#10;                // If deleted color was the selected color, pick the first available color&#10;                if (_settings.value.selectedColor == color &amp;&amp; updatedColors.isNotEmpty()) {&#10;                    newSettings = newSettings.copy(selectedColor = updatedColors.first().color)&#10;                }&#10;&#10;                repository.saveSettings(newSettings)&#10;                _settings.value = newSettings&#10;&#10;                // Remove this color from any colored days&#10;                val daysToRemove = _coloredDays.filter { it.value == color }.keys.toList()&#10;                daysToRemove.forEach { date -&gt;&#10;                    repository.removeDayColor(date)&#10;                    _coloredDays.remove(date)&#10;                }&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun resetAllData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.resetAllData()&#10;                _coloredDays.clear()&#10;                _settings.value = AppSettings()&#10;            } catch (e: Exception) {&#10;                // Handle storage errors gracefully&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getDayColor(date: LocalDate): Color? {&#10;        return _coloredDays[date]&#10;    }&#10;&#10;    fun getAvailableColors(): List&lt;Color&gt; {&#10;        return getCurrentCalendarColors().map { it.color }&#10;    }&#10;&#10;    fun getAvailableColorsWithMeanings(): List&lt;ColorWithMeaning&gt; {&#10;        return getCurrentCalendarColors()&#10;    }&#10;&#10;    // Legacy methods for global colors (used for settings)&#10;    fun getGlobalColors(): List&lt;Color&gt; {&#10;        return _settings.value.availableColors.map { it.color }&#10;    }&#10;&#10;    fun getGlobalColorsWithMeanings(): List&lt;ColorWithMeaning&gt; {&#10;        return _settings.value.availableColors&#10;    }&#10;&#10;    /**&#10;     * Get current storage type (useful for showing storage status in UI)&#10;     */&#10;    fun getStorageType() = repository.storageType&#10;&#10;    /**&#10;     * Export data for backup (if using local storage)&#10;     */&#10;    fun exportData(onResult: (String?) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                if (repository is com.germainleignel.days.storage.LocalDataRepository) {&#10;                    val exportedData = repository.exportData()&#10;                    onResult(exportedData)&#10;                } else {&#10;                    onResult(null)&#10;                }&#10;            } catch (e: Exception) {&#10;                onResult(null)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Import data from backup (if using local storage)&#10;     */&#10;    fun importData(jsonData: String, onResult: (Boolean) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                if (repository is com.germainleignel.days.storage.LocalDataRepository) {&#10;                    val success = repository.importData(jsonData)&#10;                    if (success) {&#10;                        loadData() // Reload data after import&#10;                    }&#10;                    onResult(success)&#10;                } else {&#10;                    onResult(false)&#10;                }&#10;            } catch (e: Exception) {&#10;                onResult(false)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.germainleignel.days.viewmodel&#13;&#10;&#13;&#10;import android.app.Application&#13;&#10;import androidx.compose.runtime.mutableStateMapOf&#13;&#10;import androidx.compose.runtime.mutableStateOf&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.lifecycle.AndroidViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.germainleignel.days.data.AppSettings&#13;&#10;import com.germainleignel.days.data.ColorPalette&#13;&#10;import com.germainleignel.days.data.ColorWithMeaning&#13;&#10;import com.germainleignel.days.data.model.Calendar&#13;&#10;import com.germainleignel.days.data.model.CalendarData&#13;&#10;import com.germainleignel.days.data.getDefaultColors&#13;&#10;import com.germainleignel.days.storage.DataRepository&#13;&#10;import com.germainleignel.days.storage.RepositoryFactory&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import java.time.LocalDate&#13;&#10;&#13;&#10;/**&#13;&#10; * Sealed class for different types of errors&#13;&#10; */&#13;&#10;sealed class DayTrackerError {&#13;&#10;    object StorageError : DayTrackerError()&#13;&#10;    object NetworkError : DayTrackerError()&#13;&#10;    data class ValidationError(val message: String) : DayTrackerError()&#13;&#10;    object UnknownError : DayTrackerError()&#13;&#10;}&#13;&#10;&#13;&#10;class DayTrackerViewModel(application: Application) : AndroidViewModel(application) {&#13;&#10;    private val repository: DataRepository = RepositoryFactory.getRepository(application)&#13;&#10;&#13;&#10;    // App settings state&#13;&#10;    private val _settings = MutableStateFlow(AppSettings())&#13;&#10;    val settings = _settings.asStateFlow()&#13;&#10;&#13;&#10;    // Calendar data state&#13;&#10;    private val _calendarData = MutableStateFlow(CalendarData(emptyList()))&#13;&#10;    val calendarData = _calendarData.asStateFlow()&#13;&#10;&#13;&#10;    // Map to store colored days (date -&gt; color) - cached from repository&#13;&#10;    private val _coloredDays = mutableStateMapOf&lt;LocalDate, Color&gt;()&#13;&#10;    val coloredDays: Map&lt;LocalDate, Color&gt; = _coloredDays&#13;&#10;&#13;&#10;    // Current selected date for detailed view&#13;&#10;    private val _selectedDate = mutableStateOf&lt;LocalDate?&gt;(null)&#13;&#10;    val selectedDate = _selectedDate&#13;&#10;&#13;&#10;    // Loading states&#13;&#10;    private val _isLoading = MutableStateFlow(false)&#13;&#10;    val isLoading = _isLoading.asStateFlow()&#13;&#10;&#13;&#10;    // Error states&#13;&#10;    private val _error = MutableStateFlow&lt;DayTrackerError?&gt;(null)&#13;&#10;    val error = _error.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        loadData()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun loadData() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _isLoading.value = true&#13;&#10;            _error.value = null&#13;&#10;            try {&#13;&#10;                // Load settings&#13;&#10;                _settings.value = repository.getSettings()&#13;&#10;&#13;&#10;                // Load calendar data&#13;&#10;                _calendarData.value = repository.getCalendarData()&#13;&#10;&#13;&#10;                // Load colored days for current calendar&#13;&#10;                val savedDays = repository.getAllColoredDays()&#13;&#10;                _coloredDays.clear()&#13;&#10;                _coloredDays.putAll(savedDays)&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle loading errors gracefully&#13;&#10;                _settings.value = AppSettings()&#13;&#10;                _calendarData.value = CalendarData(emptyList())&#13;&#10;                _error.value = DayTrackerError.StorageError&#13;&#10;            } finally {&#13;&#10;                _isLoading.value = false&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Calendar management methods&#13;&#10;    fun createCalendar(name: String, colors: List&lt;ColorWithMeaning&gt;) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val newCalendar = Calendar.createDefault(name, colors)&#13;&#10;                repository.saveCalendar(newCalendar)&#13;&#10;                _calendarData.value = repository.getCalendarData()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _error.value = DayTrackerError.StorageError&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun deleteCalendar(calendarId: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                repository.deleteCalendar(calendarId)&#13;&#10;                _calendarData.value = repository.getCalendarData()&#13;&#10;                // Reload colored days if the deleted calendar was selected&#13;&#10;                if (_calendarData.value.selectedCalendarId != calendarId) {&#13;&#10;                    val savedDays = repository.getAllColoredDays()&#13;&#10;                    _coloredDays.clear()&#13;&#10;                    _coloredDays.putAll(savedDays)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _error.value = DayTrackerError.StorageError&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun selectCalendar(calendarId: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                repository.setSelectedCalendar(calendarId)&#13;&#10;                _calendarData.value = repository.getCalendarData()&#13;&#10;                &#13;&#10;                // Load colored days for the selected calendar&#13;&#10;                val savedDays = repository.getAllColoredDays()&#13;&#10;                _coloredDays.clear()&#13;&#10;                _coloredDays.putAll(savedDays)&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _error.value = DayTrackerError.StorageError&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateCalendar(calendar: Calendar) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                repository.saveCalendar(calendar)&#13;&#10;                _calendarData.value = repository.getCalendarData()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _error.value = DayTrackerError.StorageError&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getSelectedCalendar(): Calendar? {&#13;&#10;        return _calendarData.value.getSelectedCalendar()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getCalendars(): List&lt;Calendar&gt; {&#13;&#10;        return _calendarData.value.calendars&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getCurrentCalendarColors(): List&lt;ColorWithMeaning&gt; {&#13;&#10;        return getSelectedCalendar()?.colorScheme ?: getAvailableColorsWithMeanings()&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Clear the current error state&#13;&#10;     */&#13;&#10;    fun clearError() {&#13;&#10;        _error.value = null&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Retry loading data after an error&#13;&#10;     */&#13;&#10;    fun retryLoadData() {&#13;&#10;        loadData()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun toggleDayColor(date: LocalDate) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val currentColor = _coloredDays[date]&#13;&#10;            if (currentColor != null) {&#13;&#10;                // If day is already colored, remove the color&#13;&#10;                removeDayColor(date)&#13;&#10;            } else {&#13;&#10;                // Color the day with the currently selected color&#13;&#10;                setDayColor(date, _settings.value.selectedColor)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun setDayColor(date: LocalDate, color: Color) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                _error.value = null&#13;&#10;                if (color == Color.Transparent) {&#13;&#10;                    // Transparent color means remove the color&#13;&#10;                    repository.removeDayColor(date)&#13;&#10;                    _coloredDays.remove(date)&#13;&#10;                } else {&#13;&#10;                    repository.saveDayColor(date, color)&#13;&#10;                    _coloredDays[date] = color&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;                _error.value = DayTrackerError.StorageError&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun removeDayColor(date: LocalDate) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                repository.removeDayColor(date)&#13;&#10;                _coloredDays.remove(date)&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearAllColors() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                repository.clearAllDayColors()&#13;&#10;                _coloredDays.clear()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateSelectedColor(color: Color) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val newSettings = _settings.value.copy(selectedColor = color)&#13;&#10;                repository.saveSettings(newSettings)&#13;&#10;                _settings.value = newSettings&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateDarkMode(isDarkMode: Boolean) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val newSettings = _settings.value.copy(&#13;&#10;                    isDarkMode = isDarkMode,&#13;&#10;                    followSystemTheme = false // When manually set, don't follow system&#13;&#10;                )&#13;&#10;                repository.saveSettings(newSettings)&#13;&#10;                _settings.value = newSettings&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun setFollowSystemTheme(follow: Boolean) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val newSettings = _settings.value.copy(followSystemTheme = follow)&#13;&#10;                repository.saveSettings(newSettings)&#13;&#10;                _settings.value = newSettings&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateColorMeaning(color: Color, meaning: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val updatedColors = _settings.value.availableColors.map { colorWithMeaning -&gt;&#13;&#10;                    if (colorWithMeaning.color == color) {&#13;&#10;                        colorWithMeaning.copy(meaning = meaning)&#13;&#10;                    } else {&#13;&#10;                        colorWithMeaning&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                val newSettings = _settings.value.copy(availableColors = updatedColors)&#13;&#10;                repository.saveSettings(newSettings)&#13;&#10;                _settings.value = newSettings&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getColorMeaning(color: Color): String {&#13;&#10;        return getCurrentCalendarColors().find { it.color == color }?.meaning ?: &quot;Custom Color&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    fun addNewColor(color: Color, meaning: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val updatedColors = _settings.value.availableColors + ColorWithMeaning(color, meaning)&#13;&#10;                val newSettings = _settings.value.copy(availableColors = updatedColors)&#13;&#10;                repository.saveSettings(newSettings)&#13;&#10;                _settings.value = newSettings&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun deleteColor(color: Color) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val updatedColors = _settings.value.availableColors.filter { it.color != color }&#13;&#10;                var newSettings = _settings.value.copy(availableColors = updatedColors)&#13;&#10;&#13;&#10;                // If deleted color was the selected color, pick the first available color&#13;&#10;                if (_settings.value.selectedColor == color &amp;&amp; updatedColors.isNotEmpty()) {&#13;&#10;                    newSettings = newSettings.copy(selectedColor = updatedColors.first().color)&#13;&#10;                }&#13;&#10;&#13;&#10;                repository.saveSettings(newSettings)&#13;&#10;                _settings.value = newSettings&#13;&#10;&#13;&#10;                // Remove this color from any colored days&#13;&#10;                val daysToRemove = _coloredDays.filter { it.value == color }.keys.toList()&#13;&#10;                daysToRemove.forEach { date -&gt;&#13;&#10;                    repository.removeDayColor(date)&#13;&#10;                    _coloredDays.remove(date)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun resetAllData() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                repository.resetAllData()&#13;&#10;                _coloredDays.clear()&#13;&#10;                _settings.value = AppSettings()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle storage errors gracefully&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getDayColor(date: LocalDate): Color? {&#13;&#10;        return _coloredDays[date]&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getAvailableColors(): List&lt;Color&gt; {&#13;&#10;        return getCurrentCalendarColors().map { it.color }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getAvailableColorsWithMeanings(): List&lt;ColorWithMeaning&gt; {&#13;&#10;        return _settings.value.availableColors&#13;&#10;    }&#13;&#10;&#13;&#10;    // Legacy methods for global colors (used for settings)&#13;&#10;    fun getGlobalColors(): List&lt;Color&gt; {&#13;&#10;        return _settings.value.availableColors.map { it.color }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getGlobalColorsWithMeanings(): List&lt;ColorWithMeaning&gt; {&#13;&#10;        return _settings.value.availableColors&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get current storage type (useful for showing storage status in UI)&#13;&#10;     */&#13;&#10;    fun getStorageType() = repository.storageType&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Export data for backup (if using local storage)&#13;&#10;     */&#13;&#10;    fun exportData(onResult: (String?) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                if (repository is com.germainleignel.days.storage.LocalDataRepository) {&#13;&#10;                    val exportedData = repository.exportData()&#13;&#10;                    onResult(exportedData)&#13;&#10;                } else {&#13;&#10;                    onResult(null)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onResult(null)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Import data from backup (if using local storage)&#13;&#10;     */&#13;&#10;    fun importData(jsonData: String, onResult: (Boolean) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                if (repository is com.germainleignel.days.storage.LocalDataRepository) {&#13;&#10;                    val success = repository.importData(jsonData)&#13;&#10;                    if (success) {&#13;&#10;                        loadData() // Reload data after import&#13;&#10;                    }&#13;&#10;                    onResult(success)&#13;&#10;                } else {&#13;&#10;                    onResult(false)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onResult(false)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>